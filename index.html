<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>JS</title>
  <style>
      h3{
          color: red
      }
  </style>
</head>
<body>
  <p>
      typeof
      === / ==
      window.onload DOMContentLoaded
      创建10个<a>点击弹出来对应的序号
      模块加载器，实现类似require。js
      数组随机排序，拼接</p>
  <h3>变量类型</h3>    
  <p>值类型和引用类型</p>   
  <p>number boolean undefined string</p>    
  <p>object array function null</p>   
  <p>typeof	number boolean undefined string object（ {} [] null ） function    typeof []  只能区分值类型的详细类型</p>   
  <p>
      NaN是一个特殊值，表示某些算数运算的结果不是数字， 使用isNaN（）来判断    
  </p>   
  <h3>
      变量计算-强制类型转换
  </h3>
      
  <p>字符串拼接 		100 + '10'</p>    
  <p>==运算符		100 == '100'  0 == ''  null == undefined</p>   
  <p>if语句			c = ''   	if(c)	</p>    
  <p>
      逻辑运算符		10&&0 //0		''||'abc' //'abc'   !window.abc //true		怎么查看变量会被转化为true/false  !!a
  </p> 
  <p>
      PS: == 会导致类型转换，尽量用===， 类似object.a == null 等同于 object.a === null || object.a === undefined 判断对象中属性是否定义，判断函数中参数是否传递
  </p>  
  <h3>JS中内置函数-----数据封装类对象</h3>   
  <p>Object/Array/Boolean/Number/String/Function/Date/RegExp/Error</p>    
  <h3>内置对象</h3>  
  <p>Math Json</p>    
  <h3>JSON</h3>   
  <p>JSON是一个JS对象，也是一种数据格式</p>   
  <p>JSON.stringify({a:10,b:20});		//JSON对象变为字符串</p>    
  <p>JSON.parse('{"a":10,"b":20}');		//字符串变为JSON</p>    
  <h3>原型和原型链</h3>    
  <h3>题目：	如何准确判断一个变量是数组类型			var arr = [];	 arr instanceof Array</h3>    
  <p>写一个原型链继承的例子					把父类赋值给子类的prototype属性</p>    
  <p>描述new一个对象的过程</p>    
  <p>创建一个新对象；this指向这个新对象；执行代码，对this赋值；返回this</p>   
  <p>zepto源码中如何使用原型链</p>        
  <h3>构造函数</h3>        
  <p>function Foo(name,age){			//注意首字母大写</p>        
  <p>this.name = name;</p>       
  <p>this.age = age;</p>   
  <p>this.class = 'class-1'</p>   
  <p>//return this</p>      
  <p>}</p>      
  <p>var f = new Foo('zyq',28);</p>     
  <h3>构造函数-扩展</h3>     
  <p>var a = {};			var a = new Object();</p>  
  <p>var a = [];			var a = new Array();</p>    
  <p>function Foo(){};	var Foo = new Function(){};</p>    
  <h3>原型规则和示例</h3>   
  <p>1.所有引用类型(array object function)都具有对象特性，即可自由扩展属性（除了null）</p>   
  <p>2.所有引用类型都有__proto__属性，属性值是一个普通对象</p>   
  <p>3.所有函数都有一个prototype属性，属性值都是一个普通对象</p>    
  <p>4.__proto__属性值指向它的构造函数的prototype属性值，即===</p>   
  <p>
      5.当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__（即构造函数的prototype）中寻找    
  </p>    
  <p>function Foo(name){</p>    
  <p>this.name = name;</p>   
  <p>}</p>   
  <p>Foo.prototype.alertName = function () {</p>     
  <p>alert(this.name);</p>   
  <p>}</p>   
  <p>var f = new Foo('zyq')</p>     
  <p>f.printName = function() {</p>   
  <p>console.log(this.name)</p>   
  <p>}</p>  
  <p>f.printName();</p>      
  <p>f.alertName();</p>  
  <p>for(item in f){</p>  
  <p>//高级浏览器已经在for in中屏蔽了来自原型的属性，但是这里还是建议加上</p>   
  <p>if(f.hasOwnProperty(item)){</p>   
  <p>console.log(item);</p> 
  <p>}</p>     
  <p>}</p>       
  <h3>原型链</h3>     
  <p>
      f.__proto__ === Foo.prototype Foo.prototype.__proto__ === Object.prototype Object.prototype.__proto__ = null
  </p>
  <p>instanceof判断一个函数是否是一个变量的构造函数		变量instanceof函数</p>  
  <p>f instanceof Foo </p>    
  <p>f的__proto__一层层往上看能不能找到Foo.prototype</p>   
  <p>f instanceof Object 也是true </p>   
  <h3>原型链继承的例子：</h3>   
  <p>function Elem(id){</p> 
  <p>this.el = document.getElementById(id);</p>
  <p>}</p>      
  <p>Elem.prototype.html=function(val){</p>   
  <p>var elem = this.el;</p>   
  <p>if(val){</p>    
  <p>elem.innerHTML = val;</p>     
  <p>return this;</p>       
  <p>}else{</p>       
  <p>return elem.innerHTML;</p>    
  <p>}</p>       
  <p>}</p>     
  <p>var div1 = new Elem('detail')</p>    
  <p>div1.html();</p>   
  <h3>作用域和闭包</h3>    
  <p>题目：	说一下对变量提升的理解</p>   
  <p>说明this几种不同的使用场景</p>  
  <p>   作为构造函数，对象属性，普通函数（window），call，apply，bind</p>
  <p>创建10个a标签，点击的时候弹出来对应的序号</p>  
  <p>如何理解作用域</p>     
  <p>实际开发中闭包的作用</p>       
  <p>执行上下文</p>    
  <p>范围：一段script或者一个函数</p>       
  <p>全局：变量定义undefined、函数						一段script</p>   
  <p>函数：变量定义undefined、函数声明、this、arguments 	函数</p>  
  <p>this</p>  
  <p>this要在执行时才能确认值</p>
  <h3>call,apply,bind:</h3>
  <p>function fn(name){</p>
  <p>   alert(name);</p>
  <p>   console.log(this);</p>
  <p>}</p>
  <p>fn()//直接调用的时候this === window</p>
  <p>fn.call({x:1},'zhangsan')//第一个参数是把这个对象赋值给this，第二个参数是传递的参数</p>
  <p>fn.apply({x:1},['zhangsan'])//和call的区别就是参数作为数组传递</p>
  <p>var fn1 = function(name){</p>
  <p>   console.log(this);</p>
  <p>}.bind({x:1})</p>
  <p>fn1('zhangsan');//bind必须用在函数表达式最后，也是给this赋值</p>
  <p></p>
  <h3>作用域</h3>
  <p>没有块级作用域,全局作用域和函数作用域</p>
  <p>if(true){</p>
  <p>   var name = 'zhangsan';</p>
  <p>}</p>
  <p>console.log(name);//可以访问</p>
  <h3>作用域链</h3>   
  <p>函数的父级作用域是定义的地方的作用域</p>
  <p>自由变量（跨作用域的变量），作用域链即自由变量的查找，闭包的两个使用场景</p>
  <h3>闭包</h3>
  <h4>函数作为返回，函数作为参数传递</h4>     
  <p>function F1(){</p>
  <p>   var a = 100</p>
  <p>   return function(){</p>
  <p>       consolo.log(a)</p>
  <p>}</p>
  <p>var f = F1()</p>
  <p>函数的父作用域和定义函数位置的父作用域</p>    
  <p>封装变量，收敛权限,外部无法修改内部变量</p>
  <p>自执行函数 (function(i){...})(i)</p> 
  <h3>异步和单线程</h3>
  <h4>题目：</h4>
  <p>同步和异步的区别？分别举一个例子</p>
  <p>一个关于setTimeout的笔试题</p>
  <p>前端使用异步的场景有哪些</p>
  <p>异步和同步最大的区别是有没有阻塞程序的运行</p>
  <p>alert是同步的，弹出框后如果不点确定会一直阻塞程序运行</p>
  <h4>需要异步的情况</h4>
  <p>可能发生等待的情况,等待过程中不能像alert一样阻塞程序，所以等待的情况都需要异步</p>
  <p>1.定时任务：setTimeout，setInterval</p>
  <p>2.网络请求：ajax请求，动态<img>加载</p>
  <p>3.事件绑定</p>
  <p>异步函数在被定义时会暂存起来，等到空闲后按照完成顺序执行</p>
  <h3>题目：</h3>
  <p>获取2017-06-10格式的日期</p>
  <p>获取随机数，要求长度一致的字符串格式</p>
  <p>写一个能遍历对象和数组的通用forEach函数</p>
  <p>Date.now()//当前事件的毫秒数</p>
  <p>var dt = new Date();</p>
  <p>dt.getTime()</p>
  <p>dt.getFullYear()</p>
  <p>dt.getMonth()</p>
  <p>dt.getDate()</p>
  <p>dt.getHours()</p>
  <p>dt.getMinites()</p>
  <p>dt.getSeconds()</p>
  <p>Math.random()</p>
  <p>url后面，随时改变和清除缓存</p>
  <h3>数组</h3>
  <p>forEach遍历</p>
  <p>   arr.forEach(funtion(item,index){})</p>
  <p>every判断所有元素是否都符合条件</p>
  <p>   var result = arr.every(funtion(item,index){</p>
  <p>       if(item < 4) { return true; }})</p>
  <p>some判断是否有至少一个元素符合条件</p>
  <p>   var result = arr.some(funtion(item,index){</p>
  <p>       if(item < 4) { return true; }})</p>
  <p>sort</p>
  <p>   arr  = arr.sort(funtion(a,b){</p>
  <p>           return a-b //从小到大排序</p>
  <p>           return b-a //从大到校排序</p>
  <p>}</p>
  <p>map对元素重新组装，生成新数组</p>
  <p>   arr = arr.map(function(item,index){</p>
  <p>       return '<b>'+item+'</b>'</p>
  <p>   })</p>
  <p>filter过滤符合条件的元素</p>
  <p>   arr = arr.filter(funtion(item,index){</p>
  <p>       if(item >= 2){</p>
  <p>           return true</p>
  <p>       }</p>
  <p>   })</p>
  <h3>对象api</h3>
  <p>for(key in obj){</p>
  <p>   if(obj.hasOwnProperty(key){</p>
  <p>       return obj.key</p>
  <p>   }</p>
  <p>})</p>
</body>
</html>